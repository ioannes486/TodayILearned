# Intro

- 지그재그 탐색
- 더 큰 2차원 배열을 2차원 배열로 탐색하려면 4중 for문이 필요하다
- 순회하는 규칙을 찾으려면 정수론적인 방법, 그리고 공식을 유도해서 일반화할 수 있는 수학적인 감각이 필요하다.

# 2차원 배열의 순회

### 행 우선순회

> 이중 for문을 사용해서 배열을 순회하는 가장 기본적인 방법이다

```python
for i in range(n): # 외부의 인덱스는 행 번호를 나타낸다
	for j in range(m): # 내부의 인덱스는 열 번호로 나타낸다
    	print(arr[i][j]) # 보통 i -> j 순서니깐 '행렬'로 외우면 된다
```

### 열 우선순회

> 똑같이 이중 for문을 사용하지만 행과 열 좌표가 바뀌어있다.

```python
for j in range(m): # 순회를 돌리는 range의 인자도 서로 달라짐에 유의
	for i in range(n): # i:n <-> j:m
    	print(arr[i][j])

```

### 지그재그 순회

> 수학공식을 이용한 규칙으로 순회를 해보자

```python
for i in range(n): #
	for j in range(m):
    	print(arr[i][j+(m-1-2*j)*(i%2)])
```

여기서 왜 이런 공식이 나올까? 지그재그순회를 위해서는 홀수번째 행과 짝수번째 행의 순회방향을 다르게 해야 한다. 즉 위 코드는 짝수번째 행 인덱스만 똑바로 순회하는 코드이다. 역방향 순회는 `m-1...m-1-1...m-1-2...m-1-j...0`번째까지 순회해야 하는데 이때 짝수번째 인덱스를 구하려면 모든 행에 대해 j가 사라지면 안된다. 그래서 `-j`를 한번 더해줘서 `m-1-2-j`가 되는것

# 델타

> 2차원 배열의 한 좌표에서 4방향의 인접배열 요소를 탐색하는 방법, 즉 한길로만 가는게 아니라 반복문으로 동시에 뻗어나가는 것

```python
# 정석 방법
N = 10
arr = [[1,2,3,4,5,5,6,4,3,5]* 10]

di = [0,1,0,-1]
dj = [1,0,-1,0]

for j in range(N-1):
    for d in range(N-1):
        ni = i + di[d]
        nj = j + dj[d]
        if 0 <= ni < N and 0<=N
            # 유효한 인덱스면 연산하셈

# 파이선의 방법
for i in range(N):
    for j in range(N):
        for di, dj in [[0,1],[1,0],[0,-1],[-1,0]]


```

# 기타

### 전치행렬

![](https://velog.velcdn.com/images/rhkdghks21/post/cf75ebed-e24a-4b9c-b263-a128dcdd582b/image.png)
